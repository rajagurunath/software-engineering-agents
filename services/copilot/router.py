from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field
import pandas as pd
from rag.sql_rag.qdrant_vector_store import IONetDataBot, add_sql_layer, refresh_preset_token
from rag.docs_rag.docs_store import create_rag_assistant
import os
from typing import List
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

router = APIRouter(prefix="/copilot", tags=["copilot"])

# --- Data Bot ---

class QueryRequest(BaseModel):
    query: str
    top_k: int = Field(5, gt=0, le=20, description="Number of relevant documents to retrieve.")

class QueryResponse(BaseModel):
    data: list
    plotly_json: str
    followup_questions: list[str]
    generated_sql: str

@router.post("/bot", response_model=QueryResponse)
async def handle_query(request: QueryRequest):
    try:
        refresh_preset_token()
        data_bot = IONetDataBot()
        add_sql_layer(data_bot)
        
        sql = data_bot.generate_sql(question=request.query)
        data = data_bot.run_sql(sql=sql)
        temp_df = pd.DataFrame(data)
        plotly_code = data_bot.generate_plotly_code(question=request.query, sql=sql, df_metadata=temp_df)
        fig = data_bot.get_plotly_figure(plotly_code=plotly_code, df=temp_df)
        plotly_json = fig.to_json()
        followup_questions = data_bot.generate_followup_questions(question=request.query, sql=sql, df=temp_df, n_questions=5)
        
        return QueryResponse(
            data=data,
            plotly_json=plotly_json,
            followup_questions=followup_questions,
            generated_sql=sql
        )
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))

# --- Docs Bot ---

class DocsQueryRequest(BaseModel):
    query: str = Field(..., description="The user's question to the RAG assistant.")
    top_k: int = Field(5, gt=0, le=20, description="Number of relevant documents to retrieve.")

class SourceInfo(BaseModel):
    score: float = Field(..., description="Relevance score of the source.")
    source_url: str | None = Field(None, description="URL of the source document.")
    image_urls: List[str] = Field([], description="List of image URLs found in the source.")
    link_urls: List[str] = Field([], description="List of hyperlink URLs found in the source.")
    source_file: str | None = Field(None, description="Original file path of the source (for debugging).")

class DocsAnswerResponse(BaseModel):
    answer: str = Field(..., description="The answer generated by the RAG assistant.")
    sources: List[SourceInfo] = Field(..., description="List of source documents used for the answer, ordered by relevance.")
    relevant_source_links: List[str] = Field([], description="List of sorted links based on relevance to the question and answer.")
    followup_questions: List[str] = Field([], description="List of follow-up questions generated based on the answer.")

@router.post("/docs_bot", response_model=DocsAnswerResponse)
async def handle_docs_query(request: DocsQueryRequest):
    try:
        logger.info(f"Received docs_bot query: {request.query}")
        assistant = create_rag_assistant(backend="qdrant")
        logger.info(f"RAG assistant created. Querying with top_k={request.top_k}")
        result = assistant.answer(query=request.query, top_k=request.top_k)
        logger.info(f"RAG assistant returned result: {result}")
        
        sources_data = result.get("sources", [])
        logger.info(f"Found {len(sources_data)} sources.")

        formatted_sources = [SourceInfo(**source) for source in sources_data]

        response = DocsAnswerResponse(
            answer=result.get("answer", "Error: No answer generated."),
            sources=formatted_sources,
            relevant_source_links=result.get("relevant_source_links", []),
            followup_questions=result.get("followup_questions", [])
        )
        logger.info(f"Returning response: {response}")
        return response
    except Exception as e:
        logger.error(f"Error in docs_bot: {e}", exc_info=True)
        raise HTTPException(status_code=500, detail=str(e))
